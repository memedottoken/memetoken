let _=!1;async function v(n,i={}){var o,d;if(_)return[];_=!0,n.setState(t=>({...t,status:t.current?"reconnecting":"connecting"}));const c=[];if((o=i.connectors)!=null&&o.length)for(const t of i.connectors){let r;typeof t=="function"?r=n._internal.connectors.setup(t):r=t,c.push(r)}else c.push(...n.connectors);let s;try{s=await((d=n.storage)==null?void 0:d.getItem("recentConnectorId"))}catch{}const e={};for(const[,t]of n.state.connections)e[t.connector.id]=1;s&&(e[s]=0);const p=Object.keys(e).length>0?[...c].sort((t,r)=>(e[t.id]??10)-(e[r.id]??10)):c;let a=!1;const f=[],u=[];for(const t of p){const r=await t.getProvider().catch(()=>{});if(!r||u.some(h=>h===r)||!await t.isAuthorized())continue;const l=await t.connect({isReconnecting:!0}).catch(()=>null);l&&(t.emitter.off("connect",n._internal.events.connect),t.emitter.on("change",n._internal.events.change),t.emitter.on("disconnect",n._internal.events.disconnect),n.setState(h=>{const y=new Map(a?h.connections:new Map).set(t.uid,{accounts:l.accounts,chainId:l.chainId,connector:t});return{...h,current:a?h.current:t.uid,connections:y}}),f.push({accounts:l.accounts,chainId:l.chainId,connector:t}),u.push(r),a=!0)}return(n.state.status==="reconnecting"||n.state.status==="connecting")&&(a?n.setState(t=>({...t,status:"connected"})):n.setState(t=>({...t,connections:new Map,current:null,status:"disconnected"}))),_=!1,f}function w(n,i){const{initialState:c,reconnectOnMount:s}=i;return c&&!n._internal.store.persist.hasHydrated()&&n.setState({...c,chainId:n.chains.some(e=>e.id===c.chainId)?c.chainId:n.chains[0].id,connections:s?c.connections:new Map,status:s?"reconnecting":"disconnected"}),{async onMount(){n._internal.ssr&&(await n._internal.store.persist.rehydrate(),n._internal.mipd&&n._internal.connectors.setState(e=>{var u;const p=new Set;for(const o of e??[])if(o.rdns){const d=Array.isArray(o.rdns)?o.rdns:[o.rdns];for(const t of d)p.add(t)}const a=[],f=((u=n._internal.mipd)==null?void 0:u.getProviders())??[];for(const o of f){if(p.has(o.info.rdns))continue;const d=n._internal.connectors.providerDetailToConnector(o),t=n._internal.connectors.setup(d);a.push(t)}return[...e,...a]})),s?v(n):n.storage&&n.setState(e=>({...e,connections:new Map}))}}}const S=Symbol(),I={install(n,i){const{config:c,reconnectOnMount:s=!0}=i;n.provide(S,c);const{onMount:e}=w(c,{...i,reconnectOnMount:s});e()}};export{I as W,S as c};
